{"t":1759714544964,"role":"interviewer","speaker":"noam","text":"hello Eva"}
{"t":1759714546570,"role":"candidate","speaker":"ava taylor","text":"Hi, nice to be here."}
{"t":1759714548817,"role":"interviewer","speaker":"noam","text":" how are you today"}
{"t":1759714549972,"role":"candidate","speaker":"ava taylor","text":"I'm doing well, thanks! How about you?"}
{"t":1759714553297,"role":"interviewer","speaker":"noam","text":" okay great"}
{"t":1759714554066,"role":"candidate","speaker":"ava taylor","text":"Awesome!"}
{"t":1759714562734,"role":"interviewer","speaker":"noam","text":" so I'm really really good we're going to do today and I react interview for meta"}
{"t":1759714563506,"role":"candidate","speaker":"ava taylor","text":"That sounds exciting! I'm looking forward to it."}
{"t":1759714573287,"role":"interviewer","speaker":"noam","text":" okay so we're going to start with a few questions and then we're going to do a coach challenge sounds good"}
{"t":1759714574372,"role":"candidate","speaker":"ava taylor","text":"Sounds good! I'm ready for your questions."}
{"t":1759714584754,"role":"interviewer","speaker":"noam","text":" okay cool so tell me about a complex reacting integration you built at what made it challenging"}
{"t":1759714586866,"role":"candidate","speaker":"ava taylor","text":"I worked on a multi-tenant React app that embedded partner widgets via iframes with Module Federation. The challenges included managing origin authentication, handling schema versioning, and ensuring failure isolation between different tenants."}
{"t":1759714617258,"role":"interviewer","speaker":"noam","text":"can you tell me a bit more about the how you handled the schema no actually tell me more about how you handled the isolation between different tenants"}
{"t":1759714619889,"role":"candidate","speaker":"ava taylor","text":"To ensure isolation between tenants, I implemented strict origin checks for all iframe communications and used separate namespaces for each tenant's data. This way, even if one tenant's widget failed, it wouldn't affect the others, maintaining a robust user experience across the app."}
{"t":1759714652973,"role":"interviewer","speaker":"noam","text":"okay and how do you handle communication between a parent app and embedded content"}
{"t":1759714654002,"role":"candidate","speaker":"ava taylor","text":"I use `postMessage` with a strict origin whitelist to ensure secure communication. The messages include typed payloads for validation, and I implement an ACK/Retry mechanism with backoff to handle any potential message loss."}
{"t":1759714665250,"role":"interviewer","speaker":"noam","text":" is there anything else but post message that you can use to do that"}
{"t":1759714666725,"role":"candidate","speaker":"ava taylor","text":"Yes, another approach could be using WebSockets for real-time communication, which allows for a persistent connection between the parent app and embedded content. This can be useful for scenarios requiring continuous data exchange, but it comes with its own complexities regarding connection management and security."}
{"t":1759714693880,"role":"interviewer","speaker":"noam","text":"when you say it comes with its own complexities so can you please describe me what kind of complexities"}
{"t":1759714695497,"role":"candidate","speaker":"ava taylor","text":"Sure! With WebSockets, you need to manage connection states, handle reconnections on network issues, and ensure proper cleanup when the connection is no longer needed. Additionally, you must implement security measures like authentication and message validation to prevent unauthorized access and data breaches."}
{"t":1759714718163,"role":"interviewer","speaker":"noam","text":" and in this case would you do it how would you manage the state of the application of the react application if you would be using a websocket"}
{"t":1759714719498,"role":"candidate","speaker":"ava taylor","text":"I would manage the application state using a combination of React's Context API and a state management library like Zustand or Redux. The WebSocket connection would be established in a context provider, which would handle incoming messages and update the global state accordingly. This way, components can subscribe to the relevant state changes and re-render as needed."}
{"t":1759714734768,"role":"interviewer","speaker":"noam","text":" is there a need here for a middleware"}
{"t":1759714740470,"role":"candidate","speaker":"ava taylor","text":"Yes, using middleware can be beneficial, especially for handling side effects related to WebSocket communication. Middleware can help manage actions like connecting, disconnecting, and processing incoming messages, ensuring that the state updates are handled in a clean and organized manner. This can also help in logging or error handling during the WebSocket lifecycle."}
{"t":1759714759615,"role":"interviewer","speaker":"noam","text":"how do you measure and improved front and performance"}
{"t":1759714765239,"role":"candidate","speaker":"ava taylor","text":"I measure frontend performance using Web Vitals metrics like LCP, CLS, and INP. To improve performance, I focus on techniques like code splitting, optimizing images, using memoization for components, and implementing lazy loading. I also validate performance improvements using the React Profiler and synthetic monitoring tools."}
{"t":1759714788230,"role":"interviewer","speaker":"noam","text":"give me one example that is beneficial for doing Lazy loading and afterwards give me an example where it doesn't make sense to do lazy loading"}
{"t":1759714790371,"role":"candidate","speaker":"ava taylor","text":"A beneficial example of lazy loading is for large images or components that are not immediately visible on the screen, like images in a gallery. This helps reduce the initial load time and improves the user experience.\n\nOn the other hand, lazy loading doesn't make sense for critical components that are essential for the initial rendering of the page, such as navigation bars or above-the-fold content, as it could lead to a delayed user experience."}
{"t":1759714811913,"role":"interviewer","speaker":"noam","text":"okay now I would like you to implement the task that we have in front of you in the code"}
{"t":1759714815775,"role":"candidate","speaker":"ava taylor","text":"Alright, I'll implement the task by adding the event listener for \"analytics:event\" messages, validating the messages, displaying the event names in a list, and simulating an event on button click. Let's do that."}
{"t":1759714834925,"role":"interviewer","speaker":"noam","text":" okay so actually I would like you to implement it and while you're implemented feel free to think out loud and tell me how your implementing it"}
{"t":1759715006798,"role":"candidate","speaker":"ava taylor","text":"I've implemented the task. Here's what I did:\n\n1. **Set up an event listener**: I created a `useEffect` hook that listens for `message` events. Inside the event handler, I check if the message is of type \"analytics:event\" and validate the structure.\n\n2. **Update state**: When a valid event is received, I update the `events` state with the new event name.\n\n3. **Cleanup**: I ensured to remove the event listener when the component unmounts to prevent memory leaks.\n\n4. **Simulate sending an event**: I added a button that, when clicked, sends a test event using `postMessage`.\n\n5. **Display events**: Finally, I rendered the list of event names below the button.\n\nCool, that should work!"}
{"t":1759715015304,"role":"interviewer","speaker":"noam","text":"okay I see what you're doing let me check it"}
{"t":1759715016756,"role":"candidate","speaker":"ava taylor","text":"Sure, take your time!"}
{"t":1759715052108,"role":"interviewer","speaker":"noam","text":"now I can see that you're using your window post message why are you using it and is there another way to do it"}
{"t":1759715054155,"role":"candidate","speaker":"ava taylor","text":"I'm using `window.postMessage` because it's a secure way to communicate between different contexts, like iframes or between a parent window and embedded content. It allows for cross-origin messaging, which is essential in multi-tenant applications.\n\nAnother way to handle communication could be using a shared state management solution, like a global store with Context API or Redux, but that would typically be limited to components within the same application context. For cross-origin scenarios, `postMessage` is generally the preferred method."}
{"t":1759715083898,"role":"interviewer","speaker":"noam","text":"okay good thank you so much"}
{"t":1759715084760,"role":"candidate","speaker":"ava taylor","text":"You're welcome! I'm glad to help."}
